module MultiSigWallet_Template {

  type ImmutableState = Struct [
    publicKeys: Seq[Ed25519PublicKey],
    requiredNumberOfSignatures: Byte
  ]

  type MutableState = Struct [
  ]

  type SelfSpawn_Payload = Struct [
    gasPrice: GasPrice,
    immutableState: ImmutableState,
    signatures: Map[Byte, Ed25519Sig]
  ];

  type Spawn_Payload = Struct [
    gasPrice: GasPrice,
    nonce: Nonce,
    immutableState: PrefixedWrapper,
    signatures: Map[Byte, Ed25519Sig]
  ];

  type LocalMethodCall_Payload = Struct [
    gasPrice: GasPrice,
    nonce: Nonce,
    signatures: Map[Byte, Ed25519Sig]
  ];

    behaviour Mount implements TemplateMountAPI[ImmutableState,MutableState] {

      fun parsePayload(tx: Transaction): ParsedPayload throws ParsingError {
        switch typeOf(tx) {
          case SelfSpawnTx: Quipu.parse[SelfSpawn_Payload](tx.payload)
          case SpawnTx: Quipu.parse[Spawn_Payload](tx.payload)
          case LocalMethodCall: Quipu.parse[LocalMethodCall_Payload](tx.payload)
          case ForeignMethodCallTx: throw Error("Not supported in this version of SVM")
          case TemplateDeployTx: throw Error("Not supported in this version of SVM")
        }
      }

      @autogenerated
      fun maxSpend(methodSelector: Int, accountImmutableState: IS, parsedPayload: ParsedPayload): CoinAmount

      fun verifyTx(accountImmutableState: IS, txSerialized: Wrapper, tx: Transaction, parsedPayload: ParsedPayload): Boolean {
        val numberOfSignaturesProvided: u16 = parsedPayload.nativePayload.signatures.size
        val combinedSizeOfSignatures: u16 = Quipu.serializedSizeOf(parsedPayload.nativePayload.signatures)
        val signedData: Wrapper = txSerialized.dropBytesRight(combinedSizeOfSignatures)

        val n: u16 = immutableState.publicKeys.size
        for ((label, signature) <- parsedPayload.nativePayload.signatures) {
          if (label > )
          val isOK: Boolean = vm.signatureValidation(signedData, immutableState.publicKeys(label), signature)
          if (! isOK)
            return false
        }

        return true
      }

      fun parseImmutableState(wrapper: Wrapper): ImmutableState {
        return vm.quipuParse[ImmutableState](wrapper)
      }

      @autogenerated
      fun parseCallArgs[T](methodSelector: u16, wrapper: Wrapper): T

      @autogenerated
      fun instanceMethods(): Seq[u16]

      @autogenerated
      fun methodSignature(methodId: u16): InstanceMethodSignature

      fun accountCreationHandler(accountAddress: Address, immutableState: ImmutableState, creator: Account): MutableState {
        if (immutableState.publicKeys.isEmpty())
          throw Error("List of public keys is empty")

        if (immutableState.publicKeys.size() > 256)
          throw Error("List of public keys has size ${immutableState.publicKeys.size()} but only up to 256 keys are supported")

        if (immutableState.requiredNumberOfSignatures > immutableState.size())
          throw Error("Required number of signatures exceed the number of public keys")

        return MutableState()
      }
    }

  module instance_methods {

    @methodSelector=16
    @maxSpend={amount}
    fun spend(recipient: Address, amount: CoinAmount) {
      hostAPI.transfer(recipient, amount)
    }

  }

}
